#!/usr/bin/env python3

"""@package test_pmodel_generator
Tests for function of package codegen.pmodel_generator.
"""

from pathlib import Path
from unittest import TestCase

import offsite.config
from offsite.codegen.generator.kerncraft_generator import KerncraftCodeGenerator
from offsite.codegen.generator.yasksite_generator import YasksiteCodeGenerator
from offsite.config import ModelToolType, init_config
from offsite.descriptions.impl.kernel_template import parse_kernel_templates
from offsite.descriptions.ode import IVP, ODEMethod


class TestPModelGenerator(TestCase):
    def setUp(self):
        # Create custom or default configuration.
        args = None
        init_config(args)
        self.config = offsite.config.offsiteConfig
        self.ivps = [IVP.from_yaml(Path('examples/ivps/InverterChain.ivp')),
                     IVP.from_yaml(Path('examples/ivps/Heat3D.ivp'))]
        self.method = ODEMethod.from_yaml(Path('examples/methods/implicit/radauIIA7.ode'))
        self.templates = parse_kernel_templates(Path('examples/kernels/pirk'), None)
        self.templates.extend(parse_kernel_templates(Path('examples/kernels/pirk_ext'), None))
    def test_types(self):
        for template in self.templates:
            if template.isIVPdependent:
                for ivp in self.ivps:
                    for kernel in template.variants:
                        codes = dict()
                        if template.modelTool == ModelToolType.KERNCRAFT:
                            if ivp.name in ['InverterChain', 'Medakzo']:
                                codes = KerncraftCodeGenerator().generate(kernel, self.method, ivp)
                        elif template.modelTool == ModelToolType.YASKSITE:
                            if ivp.name in ['Heat3D']:
                                codes = YasksiteCodeGenerator().generate(kernel, self.method, ivp)
                        for name, code in codes.items():
                            self.assertTrue(self.compare_code(name, code))
            else:
                for kernel in template.variants:
                    codes = dict()
                    if template.modelTool == ModelToolType.KERNCRAFT:
                        codes = KerncraftCodeGenerator().generate(kernel, self.method, None)
                    elif template.modelTool == ModelToolType.YASKSITE:
                        codes = YasksiteCodeGenerator().generate(kernel, self.method, None)
                    for name, code in codes.items():
                        self.assertTrue(self.compare_code(name, code))

    @staticmethod
    def compare_code(kernel: str, code: str):
        compared_codes = {
            'Approx_ij':
                'double b[s];\n'
                'double F[s][n];\n'
                'double dy[n];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int i=0; i<4; ++i) {\n'
                '#pragma ivdep\n'
                '  for (int j=0; j<n; ++j) {\n'
                '    dy[j] += 0.456 * F[i][j];\n'
                '  }\n'
                '}\n',
            'Approx_ji':
                'double b[s];\n'
                'double F[s][n];\n'
                'double dy[n];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=0; j<n; ++j) {\n'
                '  dy[j] += 0.220462211176770 * F[0][j];\n'
                '  dy[j] += 0.388193468843170 * F[1][j];\n'
                '  dy[j] += 0.328844319980060 * F[2][j];\n'
                '  dy[j] += 0.0625000000000000 * F[3][j];\n'
                '}\n',
            'ApproxUpdate_ij':
                'double h;\n'
                'double b[s];\n'
                'double F[s][n];\n'
                'double y[n];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int i=0; i<4; ++i) {\n'
                '#pragma ivdep\n'
                '  for (int j=0; j<n; ++j) {\n'
                '    y[j] += h * 0.456 * F[i][j];\n'
                '  }\n'
                '}\n',
            'ApproxUpdate_ji':
                'double h;\n'
                'double b[s];\n'
                'double F[s][n];\n'
                'double y[n];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=0; j<n; ++j) {\n'
                '  y[j] += h * 0.220462211176770 * F[0][j];\n'
                '  y[j] += h * 0.388193468843170 * F[1][j];\n'
                '  y[j] += h * 0.328844319980060 * F[2][j];\n'
                '  y[j] += h * 0.0625000000000000 * F[3][j];\n'
                '}\n',
            'LC_ijl_1':
                'double Y[s][n];\n'
                'double A[s][s];\n'
                'double tmp;\n'
                'double h;\n'
                'double F[s][n];\n'
                'double y[n];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int i=0; i<4; ++i) {\n'
                '#pragma ivdep\n'
                '  for (int j=0; j<n; ++j) {\n'
                '    Y[0][j] += 0.123 * F[i][j];\n'
                '    Y[1][j] += 0.123 * F[i][j];\n'
                '    Y[2][j] += 0.123 * F[i][j];\n'
                '    Y[3][j] += 0.123 * F[i][j];\n'
                '  }\n'
                '}\n',
            'LC_ijl_2':
                'double Y[s][n];\n'
                'double A[s][s];\n'
                'double tmp;\n'
                'double h;\n'
                'double F[s][n];\n'
                'double y[n];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=0; j<n; ++j) {\n'
                '  Y[0][j] = Y[0][j] * h + y[j];\n'
                '  Y[1][j] = Y[1][j] * h + y[j];\n'
                '  Y[2][j] = Y[2][j] * h + y[j];\n'
                '  Y[3][j] = Y[3][j] * h + y[j];\n'
                '}\n',
            'LC_ilj_1':
                'double Y[s][n];\n'
                'double A[s][s];\n'
                'double tmp;\n'
                'double h;\n'
                'double F[s][n];\n'
                'double y[n];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int i=0; i<4; ++i) {\n'
                '#pragma nounroll_and_jam\n'
                '  for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '    for (int j=0; j<n; ++j) {\n'
                '      Y[l][j] += 0.123 * F[i][j];\n'
                '    }\n'
                '  }\n'
                '}\n',
            'LC_ilj_2':
                'double Y[s][n];\n'
                'double A[s][s];\n'
                'double tmp;\n'
                'double h;\n'
                'double F[s][n];\n'
                'double y[n];\n'
                '\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=0; j<n; ++j) {\n'
                '    Y[l][j] = Y[l][j] * h + y[j];\n'
                '  }\n'
                '}\n',
            'LC_jil':
                'double Y[s][n];\n'
                'double Yn[s];\n'
                'double A[s][s];\n'
                'double tmp;\n'
                'double h;\n'
                'double F[s][n];\n'
                'double y[n];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=0; j<n; ++j) {\n'
                '  Yn[0] += 0.112999479323160 * F[0][j];\n'
                '  Yn[1] += 0.234383995747400 * F[0][j];\n'
                '  Yn[2] += 0.216681784623250 * F[0][j];\n'
                '  Yn[3] += 0.220462211176770 * F[0][j];\n'
                '  Yn[0] += -0.0403092207235200 * F[1][j];\n'
                '  Yn[1] += 0.206892573935360 * F[1][j];\n'
                '  Yn[2] += 0.406123263867370 * F[1][j];\n'
                '  Yn[3] += 0.388193468843170 * F[1][j];\n'
                '  Yn[0] += 0.0258023774203400 * F[2][j];\n'
                '  Yn[1] += -0.0478571280485400 * F[2][j];\n'
                '  Yn[2] += 0.189036518170060 * F[2][j];\n'
                '  Yn[3] += 0.328844319980060 * F[2][j];\n'
                '  Yn[0] += -0.00990467650730000 * F[3][j];\n'
                '  Yn[1] += 0.0160474228065200 * F[3][j];\n'
                '  Yn[2] += -0.0241821048998300 * F[3][j];\n'
                '  Yn[3] += 0.0625000000000000 * F[3][j];\n'
                '  Y[0][j] = Yn[0] * h + y[j];\n'
                '  Y[1][j] = Yn[1] * h + y[j];\n'
                '  Y[2][j] = Yn[2] * h + y[j];\n'
                '  Y[3][j] = Yn[3] * h + y[j];\n'
                '}\n',
            'LC_jli':
                'double Y[s][n];\n'
                'double A[s][s];\n'
                'double tmp;\n'
                'double h;\n'
                'double F[s][n];\n'
                'double y[n];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=0; j<n; ++j) {\n'
                '  tmp += 0.112999479323160 * F[0][j];\n'
                '  tmp += -0.0403092207235200 * F[1][j];\n'
                '  tmp += 0.0258023774203400 * F[2][j];\n'
                '  tmp += -0.00990467650730000 * F[3][j];\n'
                '  Y[0][j] = tmp * h + y[j];\n'
                '  tmp += 0.234383995747400 * F[0][j];\n'
                '  tmp += 0.206892573935360 * F[1][j];\n'
                '  tmp += -0.0478571280485400 * F[2][j];\n'
                '  tmp += 0.0160474228065200 * F[3][j];\n'
                '  Y[1][j] = tmp * h + y[j];\n'
                '  tmp += 0.216681784623250 * F[0][j];\n'
                '  tmp += 0.406123263867370 * F[1][j];\n'
                '  tmp += 0.189036518170060 * F[2][j];\n'
                '  tmp += -0.0241821048998300 * F[3][j];\n'
                '  Y[2][j] = tmp * h + y[j];\n'
                '  tmp += 0.220462211176770 * F[0][j];\n'
                '  tmp += 0.388193468843170 * F[1][j];\n'
                '  tmp += 0.328844319980060 * F[2][j];\n'
                '  tmp += 0.0625000000000000 * F[3][j];\n'
                '  Y[3][j] = tmp * h + y[j];\n'
                '}\n',
            'LC_lij_1':
                'double Y[s][n];\n'
                'double A[s][s];\n'
                'double tmp;\n'
                'double h;\n'
                'double F[s][n];\n'
                'double y[n];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma nounroll_and_jam\n'
                '  for (int i=0; i<4; ++i) {\n'
                '#pragma ivdep\n'
                '    for (int j=0; j<n; ++j) {\n'
                '      Y[l][j] += 0.123 * F[i][j];\n'
                '    }\n'
                '  }\n'
                '}\n',
            'LC_lij_2':
                'double Y[s][n];\n'
                'double A[s][s];\n'
                'double tmp;\n'
                'double h;\n'
                'double F[s][n];\n'
                'double y[n];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=0; j<n; ++j) {\n'
                '    Y[l][j] = Y[l][j] * h + y[j];\n'
                '  }\n'
                '}\n',
            'LC_lji':
                'double Y[s][n];\n'
                'double A[s][s];\n'
                'double tmp;\n'
                'double h;\n'
                'double F[s][n];\n'
                'double y[n];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=0; j<n; ++j) {\n'
                '    tmp += 0.123 * F[0][j];\n'
                '    tmp += 0.123 * F[1][j];\n'
                '    tmp += 0.123 * F[2][j];\n'
                '    tmp += 0.123 * F[3][j];\n'
                '    Y[l][j] = tmp * h + y[j];\n'
                '  }\n'
                '}\n',
            'LC_RHS_lij_1_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double F[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '  for (int i=0; i<4; ++i) {\n'
                '#pragma ivdep\n'
                '    for (int j=1; j<1 + n - 1; ++j) {\n'
                '      Y[j] += 0.123 * Fprev[i][j];\n'
                '    }\n'
                '  }\n'
                '}\n',
            'LC_RHS_lij_2_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double F[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    Y[j] = Y[j] * h + y[j];\n'
                '  }\n'
                '}\n',
            'LC_RHS_lij_3_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double F[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    F[l][j] = (((5.00000000000000 - Y[j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[j-1] - 1.00000000000000) * (Y[j-1] - 1.00000000000000) - (Y[j-1] - Y[j] - 1.00000000000000) * (Y[j-1] - Y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  }\n'
                '}\n',
            'LC_RHS_lji_1_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double F[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    Y[j] += 0.123 * Fprev[0][j];\n'
                '    Y[j] += 0.123 * Fprev[1][j];\n'
                '    Y[j] += 0.123 * Fprev[2][j];\n'
                '    Y[j] += 0.123 * Fprev[3][j];\n'
                '    Y[j] = Y[j] * h + y[j];\n'
                '  }\n'
                '}\n',
            'LC_RHS_lji_2_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double F[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    F[l][j] = (((5.00000000000000 - Y[j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[j-1] - 1.00000000000000) * (Y[j-1] - 1.00000000000000) - (Y[j-1] - Y[j] - 1.00000000000000) * (Y[j-1] - Y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  }\n'
                '}\n',
            'LC_RHS_Approx_lij_1_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double dy[n];\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '  for (int i=0; i<4; ++i) {\n'
                '#pragma ivdep\n'
                '    for (int j=1; j<1 + n - 1; ++j) {\n'
                '      Y[j] += 0.123 * Fprev[i][j];\n'
                '    }\n'
                '  }\n'
                '}\n',
            'LC_RHS_Approx_lij_2_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double dy[n];\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    Y[j] = Y[j] * h + y[j];\n'
                '  }\n'
                '}\n',
            'LC_RHS_Approx_lij_3_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double dy[n];\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    dy[j] += 0.456 * ((((5.00000000000000 - Y[j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[j-1] - 1.00000000000000) * (Y[j-1] - 1.00000000000000) - (Y[j-1] - Y[j] - 1.00000000000000) * (Y[j-1] - Y[j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '  }\n'
                '}\n',
            'LC_RHS_Approx_lji_1_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double dy[n];\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    Y[j] += 0.123 * Fprev[0][j];\n'
                '    Y[j] += 0.123 * Fprev[1][j];\n'
                '    Y[j] += 0.123 * Fprev[2][j];\n'
                '    Y[j] += 0.123 * Fprev[3][j];\n'
                '    Y[j] = Y[j] * h + y[j];\n'
                '  }\n'
                '}\n',
            'LC_RHS_Approx_lji_2_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double dy[n];\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    dy[j] += 0.456 * ((((5.00000000000000 - Y[j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[j-1] - 1.00000000000000) * (Y[j-1] - 1.00000000000000) - (Y[j-1] - Y[j] - 1.00000000000000) * (Y[j-1] - Y[j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '  }\n'
                '}\n',
            'LC_RHS_Approx_Update_lij_1_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '  for (int i=0; i<4; ++i) {\n'
                '#pragma ivdep\n'
                '    for (int j=1; j<1 + n - 1; ++j) {\n'
                '      Y[j] += 0.123 * Fprev[i][j];\n'
                '    }\n'
                '  }\n'
                '}\n',
            'LC_RHS_Approx_Update_lij_2_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    Y[j] = Y[j] * h + y[j];\n'
                '  }\n'
                '}\n',
            'LC_RHS_Approx_Update_lij_3_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    y[j] += h * 0.456 * ((((5.00000000000000 - Y[j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[j-1] - 1.00000000000000) * (Y[j-1] - 1.00000000000000) - (Y[j-1] - Y[j] - 1.00000000000000) * (Y[j-1] - Y[j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '  }\n'
                '}\n',
            'LC_RHS_Approx_Update_lji_1_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    Y[j] += 0.123 * Fprev[0][j];\n'
                '    Y[j] += 0.123 * Fprev[1][j];\n'
                '    Y[j] += 0.123 * Fprev[2][j];\n'
                '    Y[j] += 0.123 * Fprev[3][j];\n'
                '    Y[j] = Y[j] * h + y[j];\n'
                '  }\n'
                '}\n',
            'LC_RHS_Approx_Update_lji_2_InverterChain':
                'double Y[n];\n'
                'double Fprev[s][n];\n'
                'double A[s][s];\n'
                'double y[n];\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    y[j] += h * 0.456 * ((((5.00000000000000 - Y[j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[j-1] - 1.00000000000000) * (Y[j-1] - 1.00000000000000) - (Y[j-1] - Y[j] - 1.00000000000000) * (Y[j-1] - Y[j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '  }\n'
                '}\n',
            'RHS_Approx_ij_InverterChain':
                'double Y[s][n];\n'
                'double dy[n];\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                'for (int i=0; i<4; ++i) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    dy[j] += 0.456 * ((((5.00000000000000 - Y[i][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[i][j-1] - 1.00000000000000) * (Y[i][j-1] - 1.00000000000000) - (Y[i][j-1] - Y[i][j] - 1.00000000000000) * (Y[i][j-1] - Y[i][j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '  }\n'
                '}\n',
            'RHS_Approx_ji_InverterChain':
                'double Y[s][n];\n'
                'double dy[n];\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=1; j<1 + n - 1; ++j) {\n'
                '  dy[j] = 0.220462211176770 * ((((5.00000000000000 - Y[0][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[0][j-1] - 1.00000000000000) * (Y[0][j-1] - 1.00000000000000) - (Y[0][j-1] - Y[0][j] - 1.00000000000000) * (Y[0][j-1] - Y[0][j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '  dy[j] += 0.388193468843170 * ((((5.00000000000000 - Y[1][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[1][j-1] - 1.00000000000000) * (Y[1][j-1] - 1.00000000000000) - (Y[1][j-1] - Y[1][j] - 1.00000000000000) * (Y[1][j-1] - Y[1][j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '  dy[j] += 0.328844319980060 * ((((5.00000000000000 - Y[2][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[2][j-1] - 1.00000000000000) * (Y[2][j-1] - 1.00000000000000) - (Y[2][j-1] - Y[2][j] - 1.00000000000000) * (Y[2][j-1] - Y[2][j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '  dy[j] += 0.0625000000000000 * ((((5.00000000000000 - Y[3][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[3][j-1] - 1.00000000000000) * (Y[3][j-1] - 1.00000000000000) - (Y[3][j-1] - Y[3][j] - 1.00000000000000) * (Y[3][j-1] - Y[3][j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '}\n',
            'RHS_Approx_Update_ij_InverterChain':
                'double y[n];\n'
                'double Y[s][n];\n'
                'double dy;\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int i=0; i<4; ++i) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    y[j] += h * 0.456 * ((((5.00000000000000 - Y[i][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[i][j-1] - 1.00000000000000) * (Y[i][j-1] - 1.00000000000000) - (Y[i][j-1] - Y[i][j] - 1.00000000000000) * (Y[i][j-1] - Y[i][j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '  }\n'
                '}\n',
            'RHS_Approx_Update_ji_InverterChain':
                'double y[n];\n'
                'double Y[s][n];\n'
                'double dy;\n'
                'double b[s];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=1; j<1 + n - 1; ++j) {\n'
                '  dy = 0.220462211176770 * ((((5.00000000000000 - Y[0][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[0][j-1] - 1.00000000000000) * (Y[0][j-1] - 1.00000000000000) - (Y[0][j-1] - Y[0][j] - 1.00000000000000) * (Y[0][j-1] - Y[0][j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '  dy += 0.388193468843170 * ((((5.00000000000000 - Y[1][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[1][j-1] - 1.00000000000000) * (Y[1][j-1] - 1.00000000000000) - (Y[1][j-1] - Y[1][j] - 1.00000000000000) * (Y[1][j-1] - Y[1][j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '  dy += 0.328844319980060 * ((((5.00000000000000 - Y[2][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[2][j-1] - 1.00000000000000) * (Y[2][j-1] - 1.00000000000000) - (Y[2][j-1] - Y[2][j] - 1.00000000000000) * (Y[2][j-1] - Y[2][j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '  dy += 0.0625000000000000 * ((((5.00000000000000 - Y[3][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[3][j-1] - 1.00000000000000) * (Y[3][j-1] - 1.00000000000000) - (Y[3][j-1] - Y[3][j] - 1.00000000000000) * (Y[3][j-1] - Y[3][j] - 1.00000000000000)))) / 0.00100000000000000));\n'
                '  y[j] += h * dy;\n'
                '}\n',
            'RHS_LC_ijl_1_InverterChain':
                'double Yprev[s][n];\n'
                'double Ycur[s][n];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int i=0; i<4; ++i) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    f = (((5.00000000000000 - Yprev[i][j]) * 5000.00000000000 - (0.000200000000000000 * ((Yprev[i][j-1] - 1.00000000000000) * (Yprev[i][j-1] - 1.00000000000000) - (Yprev[i][j-1] - Yprev[i][j] - 1.00000000000000) * (Yprev[i][j-1] - Yprev[i][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '    Ycur[0][j] += 0.123 * f;\n'
                '    Ycur[1][j] += 0.123 * f;\n'
                '    Ycur[2][j] += 0.123 * f;\n'
                '    Ycur[3][j] += 0.123 * f;\n'
                '  }\n'
                '}\n',
            'RHS_LC_ijl_2_InverterChain':
                'double Yprev[s][n];\n'
                'double Ycur[s][n];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=1; j<1 + n - 1; ++j) {\n'
                '  Ycur[0][j] = Ycur[0][j] * h + y[j];\n'
                '  Ycur[1][j] = Ycur[1][j] * h + y[j];\n'
                '  Ycur[2][j] = Ycur[2][j] * h + y[j];\n'
                '  Ycur[3][j] = Ycur[3][j] * h + y[j];\n'
                '}\n',
            'RHS_LC_ilj_1_InverterChain':
                'double Yprev[s][n];\n'
                'double Ycur[s][n];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double Fn[n];\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int i=0; i<4; ++i) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    Fn[j] = (((5.00000000000000 - Yprev[i][j]) * 5000.00000000000 - (0.000200000000000000 * ((Yprev[i][j-1] - 1.00000000000000) * (Yprev[i][j-1] - 1.00000000000000) - (Yprev[i][j-1] - Yprev[i][j] - 1.00000000000000) * (Yprev[i][j-1] - Yprev[i][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  }\n'
                '}\n',
            'RHS_LC_ilj_2_InverterChain':
                'double Yprev[s][n];\n'
                'double Ycur[s][n];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double Fn[n];\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int i=0; i<4; ++i) {\n'
                '  for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '    for (int j=1; j<1 + n - 1; ++j) {\n'
                '      Ycur[l][j] += 0.123 * Fn[j];\n'
                '    }\n'
                '  }\n'
                '}\n',
            'RHS_LC_ilj_3_InverterChain':
                'double Yprev[s][n];\n'
                'double Ycur[s][n];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double Fn[n];\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    Ycur[l][j] = Ycur[l][j] * h + y[j];\n'
                '  }\n'
                '}\n',
            'RHS_LC_jil_InverterChain':
                'double Yprev[s][n];\n'
                'double Ycur[s][n];\n'
                'double tmp[s];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=1; j<1 + n - 1; ++j) {\n'
                '  f = (((5.00000000000000 - Yprev[0][j]) * 5000.00000000000 - (0.000200000000000000 * ((Yprev[0][j-1] - 1.00000000000000) * (Yprev[0][j-1] - 1.00000000000000) - (Yprev[0][j-1] - Yprev[0][j] - 1.00000000000000) * (Yprev[0][j-1] - Yprev[0][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  tmp[0] = 0.112999479323160 * f;\n'
                '  tmp[1] = 0.234383995747400 * f;\n'
                '  tmp[2] = 0.216681784623250 * f;\n'
                '  tmp[3] = 0.220462211176770 * f;\n'
                '  f = (((5.00000000000000 - Yprev[1][j]) * 5000.00000000000 - (0.000200000000000000 * ((Yprev[1][j-1] - 1.00000000000000) * (Yprev[1][j-1] - 1.00000000000000) - (Yprev[1][j-1] - Yprev[1][j] - 1.00000000000000) * (Yprev[1][j-1] - Yprev[1][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  tmp[0] += -0.0403092207235200 * f;\n'
                '  tmp[1] += 0.206892573935360 * f;\n'
                '  tmp[2] += 0.406123263867370 * f;\n'
                '  tmp[3] += 0.388193468843170 * f;\n'
                '  f = (((5.00000000000000 - Yprev[2][j]) * 5000.00000000000 - (0.000200000000000000 * ((Yprev[2][j-1] - 1.00000000000000) * (Yprev[2][j-1] - 1.00000000000000) - (Yprev[2][j-1] - Yprev[2][j] - 1.00000000000000) * (Yprev[2][j-1] - Yprev[2][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  tmp[0] += 0.0258023774203400 * f;\n'
                '  tmp[1] += -0.0478571280485400 * f;\n'
                '  tmp[2] += 0.189036518170060 * f;\n'
                '  tmp[3] += 0.328844319980060 * f;\n'
                '  f = (((5.00000000000000 - Yprev[3][j]) * 5000.00000000000 - (0.000200000000000000 * ((Yprev[3][j-1] - 1.00000000000000) * (Yprev[3][j-1] - 1.00000000000000) - (Yprev[3][j-1] - Yprev[3][j] - 1.00000000000000) * (Yprev[3][j-1] - Yprev[3][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  tmp[0] += -0.00990467650730000 * f;\n'
                '  tmp[1] += 0.0160474228065200 * f;\n'
                '  tmp[2] += -0.0241821048998300 * f;\n'
                '  tmp[3] += 0.0625000000000000 * f;\n'
                '  Ycur[0][j] = tmp[0] * h + y[j];\n'
                '  Ycur[1][j] = tmp[1] * h + y[j];\n'
                '  Ycur[2][j] = tmp[2] * h + y[j];\n'
                '  Ycur[3][j] = tmp[3] * h + y[j];\n'
                '}\n',
            'RHS_LC_jli_InverterChain':
                'double Yprev[s][n];\n'
                'double Ycur[s][n];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double Fs[s];\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=1; j<1 + n - 1; ++j) {\n'
                '  Fs[0] = (((5.00000000000000 - Yprev[0][j]) * 5000.00000000000 - (0.000200000000000000 * ((Yprev[0][j-1] - 1.00000000000000) * (Yprev[0][j-1] - 1.00000000000000) - (Yprev[0][j-1] - Yprev[0][j] - 1.00000000000000) * (Yprev[0][j-1] - Yprev[0][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  Fs[1] = (((5.00000000000000 - Yprev[1][j]) * 5000.00000000000 - (0.000200000000000000 * ((Yprev[1][j-1] - 1.00000000000000) * (Yprev[1][j-1] - 1.00000000000000) - (Yprev[1][j-1] - Yprev[1][j] - 1.00000000000000) * (Yprev[1][j-1] - Yprev[1][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  Fs[2] = (((5.00000000000000 - Yprev[2][j]) * 5000.00000000000 - (0.000200000000000000 * ((Yprev[2][j-1] - 1.00000000000000) * (Yprev[2][j-1] - 1.00000000000000) - (Yprev[2][j-1] - Yprev[2][j] - 1.00000000000000) * (Yprev[2][j-1] - Yprev[2][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  Fs[3] = (((5.00000000000000 - Yprev[3][j]) * 5000.00000000000 - (0.000200000000000000 * ((Yprev[3][j-1] - 1.00000000000000) * (Yprev[3][j-1] - 1.00000000000000) - (Yprev[3][j-1] - Yprev[3][j] - 1.00000000000000) * (Yprev[3][j-1] - Yprev[3][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  tmp_s = 0.112999479323160 * Fs[0];\n'
                '  tmp_s += -0.0403092207235200 * Fs[0];\n'
                '  tmp_s += 0.0258023774203400 * Fs[0];\n'
                '  tmp_s += -0.00990467650730000 * Fs[0];\n'
                '  Ycur[0][j] = tmp_s * h + y[j];\n'
                '  tmp_s = 0.234383995747400 * Fs[1];\n'
                '  tmp_s += 0.206892573935360 * Fs[1];\n'
                '  tmp_s += -0.0478571280485400 * Fs[1];\n'
                '  tmp_s += 0.0160474228065200 * Fs[1];\n'
                '  Ycur[1][j] = tmp_s * h + y[j];\n'
                '  tmp_s = 0.216681784623250 * Fs[2];\n'
                '  tmp_s += 0.406123263867370 * Fs[2];\n'
                '  tmp_s += 0.189036518170060 * Fs[2];\n'
                '  tmp_s += -0.0241821048998300 * Fs[2];\n'
                '  Ycur[2][j] = tmp_s * h + y[j];\n'
                '  tmp_s = 0.220462211176770 * Fs[3];\n'
                '  tmp_s += 0.388193468843170 * Fs[3];\n'
                '  tmp_s += 0.328844319980060 * Fs[3];\n'
                '  tmp_s += 0.0625000000000000 * Fs[3];\n'
                '  Ycur[3][j] = tmp_s * h + y[j];\n'
                '}\n',
            'RHS_LC_predictor_ijl_1_InverterChain':
                'double Ycur[s][n];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int i=0; i<4; ++i) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    f = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '    Ycur[0][j] += 0.123 * f;\n'
                '    Ycur[1][j] += 0.123 * f;\n'
                '    Ycur[2][j] += 0.123 * f;\n'
                '    Ycur[3][j] += 0.123 * f;\n'
                '  }\n'
                '}\n',
            'RHS_LC_predictor_ijl_2_InverterChain':
                'double Ycur[s][n];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=1; j<1 + n - 1; ++j) {\n'
                '  Ycur[0][j] = Ycur[0][j] * h + y[j];\n'
                '  Ycur[1][j] = Ycur[1][j] * h + y[j];\n'
                '  Ycur[2][j] = Ycur[2][j] * h + y[j];\n'
                '  Ycur[3][j] = Ycur[3][j] * h + y[j];\n'
                '}\n',
            'RHS_LC_predictor_ilj_1_InverterChain':
                'double Ycur[s][n];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double Fn[n];\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int i=0; i<4; ++i) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    Fn[j] = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  }\n'
                '}\n',
            'RHS_LC_predictor_ilj_2_InverterChain':
                'double Ycur[s][n];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double Fn[n];\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int i=0; i<4; ++i) {\n'
                '  for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '    for (int j=1; j<1 + n - 1; ++j) {\n'
                '      Ycur[l][j] += 0.123 * Fn[j];\n'
                '    }\n'
                '  }\n'
                '}\n',
            'RHS_LC_predictor_ilj_3_InverterChain':
                'double Ycur[s][n];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double Fn[n];\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                '  for (int j=1; j<1 + n - 1; ++j) {\n'
                '    Ycur[l][j] = Ycur[l][j] * h + y[j];\n'
                '  }\n'
                '}\n',
            'RHS_LC_predictor_jil_InverterChain':
                'double Ycur[s][n];\n'
                'double tmp[s];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=1; j<1 + n - 1; ++j) {\n'
                '  f = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  tmp[0] = 0.112999479323160 * f;\n'
                '  tmp[1] = 0.234383995747400 * f;\n'
                '  tmp[2] = 0.216681784623250 * f;\n'
                '  tmp[3] = 0.220462211176770 * f;\n'
                '  f = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  tmp[0] += -0.0403092207235200 * f;\n'
                '  tmp[1] += 0.206892573935360 * f;\n'
                '  tmp[2] += 0.406123263867370 * f;\n'
                '  tmp[3] += 0.388193468843170 * f;\n'
                '  f = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  tmp[0] += 0.0258023774203400 * f;\n'
                '  tmp[1] += -0.0478571280485400 * f;\n'
                '  tmp[2] += 0.189036518170060 * f;\n'
                '  tmp[3] += 0.328844319980060 * f;\n'
                '  f = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  tmp[0] += -0.00990467650730000 * f;\n'
                '  tmp[1] += 0.0160474228065200 * f;\n'
                '  tmp[2] += -0.0241821048998300 * f;\n'
                '  tmp[3] += 0.0625000000000000 * f;\n'
                '  Ycur[0][j] = tmp[0] * h + y[j];\n'
                '  Ycur[1][j] = tmp[1] * h + y[j];\n'
                '  Ycur[2][j] = tmp[2] * h + y[j];\n'
                '  Ycur[3][j] = tmp[3] * h + y[j];\n'
                '}\n',
            'RHS_LC_predictor_jli_InverterChain':
                'double Ycur[s][n];\n'
                'double A[s][s];\n'
                'double f;\n'
                'double Fs[s];\n'
                'double y[n];\n'
                'double tmp_s;\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=1; j<1 + n - 1; ++j) {\n'
                '  Fs[0] = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  Fs[1] = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  Fs[2] = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  Fs[3] = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  tmp_s = 0.112999479323160 * Fs[0];\n'
                '  tmp_s += -0.0403092207235200 * Fs[0];\n'
                '  tmp_s += 0.0258023774203400 * Fs[0];\n'
                '  tmp_s += -0.00990467650730000 * Fs[0];\n'
                '  Ycur[0][j] = tmp_s * h + y[j];\n'
                '  tmp_s = 0.234383995747400 * Fs[1];\n'
                '  tmp_s += 0.206892573935360 * Fs[1];\n'
                '  tmp_s += -0.0478571280485400 * Fs[1];\n'
                '  tmp_s += 0.0160474228065200 * Fs[1];\n'
                '  Ycur[1][j] = tmp_s * h + y[j];\n'
                '  tmp_s = 0.216681784623250 * Fs[2];\n'
                '  tmp_s += 0.406123263867370 * Fs[2];\n'
                '  tmp_s += 0.189036518170060 * Fs[2];\n'
                '  tmp_s += -0.0241821048998300 * Fs[2];\n'
                '  Ycur[2][j] = tmp_s * h + y[j];\n'
                '  tmp_s = 0.220462211176770 * Fs[3];\n'
                '  tmp_s += 0.388193468843170 * Fs[3];\n'
                '  tmp_s += 0.328844319980060 * Fs[3];\n'
                '  tmp_s += 0.0625000000000000 * Fs[3];\n'
                '  Ycur[3][j] = tmp_s * h + y[j];\n'
                '}\n',
            'RHS_jl_InverterChain':
                'double Y[s][n];\n'
                'double F[s][n];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=1; j<1 + n - 1; ++j) {\n'
                '  F[0][j] = (((5.00000000000000 - Y[0][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[0][j-1] - 1.00000000000000) * (Y[0][j-1] - 1.00000000000000) - (Y[0][j-1] - Y[0][j] - 1.00000000000000) * (Y[0][j-1] - Y[0][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  F[1][j] = (((5.00000000000000 - Y[1][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[1][j-1] - 1.00000000000000) * (Y[1][j-1] - 1.00000000000000) - (Y[1][j-1] - Y[1][j] - 1.00000000000000) * (Y[1][j-1] - Y[1][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  F[2][j] = (((5.00000000000000 - Y[2][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[2][j-1] - 1.00000000000000) * (Y[2][j-1] - 1.00000000000000) - (Y[2][j-1] - Y[2][j] - 1.00000000000000) * (Y[2][j-1] - Y[2][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  F[3][j] = (((5.00000000000000 - Y[3][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[3][j-1] - 1.00000000000000) * (Y[3][j-1] - 1.00000000000000) - (Y[3][j-1] - Y[3][j] - 1.00000000000000) * (Y[3][j-1] - Y[3][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '}\n',
            'RHS_lj_InverterChain':
                'double Y[s][n];\n'
                'double F[s][n];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                'for (int j=1; j<1 + n - 1; ++j) {\n'
                '  F[l][j] = (((5.00000000000000 - Y[l][j]) * 5000.00000000000 - (0.000200000000000000 * ((Y[l][j-1] - 1.00000000000000) * (Y[l][j-1] - 1.00000000000000) - (Y[l][j-1] - Y[l][j] - 1.00000000000000) * (Y[l][j-1] - Y[l][j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '}\n'
                '}\n',
            'RHS_predictor_jl_InverterChain':
                'double y[n];\n'
                'double F[s][n];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                '#pragma ivdep\n'
                'for (int j=1; j<1 + n - 1; ++j) {\n'
                '  F[0][j] = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  F[1][j] = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  F[2][j] = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '  F[3][j] = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '}\n',
            'RHS_predictor_lj_InverterChain':
                'double y[n];\n'
                'double F[s][n];\n'
                'double h;\n'
                'double t;\n'
                'double c[s];\n'
                '\n'
                'for (int l=0; l<4; ++l) {\n'
                '#pragma ivdep\n'
                'for (int j=1; j<1 + n - 1; ++j) {\n'
                '  F[l][j] = (((5.00000000000000 - y[j]) * 5000.00000000000 - (0.000200000000000000 * ((y[j-1] - 1.00000000000000) * (y[j-1] - 1.00000000000000) - (y[j-1] - y[j] - 1.00000000000000) * (y[j-1] - y[j] - 1.00000000000000)))) / 0.00100000000000000);\n'
                '}\n'
                '}\n',
            'Update_j':
                'double h;\n'
                'double y[n];\n'
                'double dy[n];\n'
                '\n'
                '#pragma nounroll_and_jam\n'
                '#pragma ivdep\n'
                'for (int j=0; j<n; ++j) {\n'
                '  y[j] += h * dy[j];\n'
                '}\n',
            'ys_Approx_ji_plain_Heat3D':
                'PARAM dt;\n'
                'GRID_POINT_ARRAY b[4];\n'
                'GRID_ARRAY F[4];\n'
                'GRID_POINT tmp;\n'
                '\n'
                'tmp = tmp + 0.220462211176770 * F[0];\n'
                'tmp = tmp + 0.388193468843170 * F[1];\n'
                'tmp = tmp + 0.328844319980060 * F[2];\n'
                'tmp = tmp + 0.0625000000000000 * F[3];\n'
                'y_old = tmp;\n',
            'ys_ApproxUpdate_ji_plain_Heat3D':
                'PARAM dt;\n'
                'PARAM h;\n'
                'GRID_POINT_ARRAY b[4];\n'
                'GRID_ARRAY F[4];\n'
                'GRID_POINT tmp;\n'
                '\n'
                'tmp = tmp + h * 0.220462211176770 * F[0];\n'
                'tmp = tmp + h * 0.388193468843170 * F[1];\n'
                'tmp = tmp + h * 0.328844319980060 * F[2];\n'
                'tmp = tmp + h * 0.0625000000000000 * F[3];\n'
                'y_old = tmp;\n',
            'ys_LC_jil_plain_Heat3D':
                'GRID_ARRAY Y[4];\n'
                'GRID_ARRAY F[4];\n'
                'GRID_POINT_ARRAY tmp_arr[4];\n'
                'PARAM h;\n'
                '\n'
                'tmp_arr[0] =  0.112999479323160 * F[0];\n'
                'tmp_arr[1] =  0.234383995747400 * F[0];\n'
                'tmp_arr[2] =  0.216681784623250 * F[0];\n'
                'tmp_arr[3] =  0.220462211176770 * F[0];\n'
                'tmp_arr[0] +=  -0.0403092207235200 * F[1];\n'
                'tmp_arr[1] +=  0.206892573935360 * F[1];\n'
                'tmp_arr[2] +=  0.406123263867370 * F[1];\n'
                'tmp_arr[3] +=  0.388193468843170 * F[1];\n'
                'tmp_arr[0] +=  0.0258023774203400 * F[2];\n'
                'tmp_arr[1] +=  -0.0478571280485400 * F[2];\n'
                'tmp_arr[2] +=  0.189036518170060 * F[2];\n'
                'tmp_arr[3] +=  0.328844319980060 * F[2];\n'
                'tmp_arr[0] +=  -0.00990467650730000 * F[3];\n'
                'tmp_arr[1] +=  0.0160474228065200 * F[3];\n'
                'tmp_arr[2] +=  -0.0241821048998300 * F[3];\n'
                'tmp_arr[3] +=  0.0625000000000000 * F[3];\n'
                'Y[0] = tmp_arr[0] * h + y_old;\n'
                'Y[1] = tmp_arr[1] * h + y_old;\n'
                'Y[2] = tmp_arr[2] * h + y_old;\n'
                'Y[3] = tmp_arr[3] * h + y_old;\n',
            'ys_LC_jli_plain_Heat3D':
                'GRID_ARRAY Y[4];\n'
                'GRID_ARRAY F[4];\n'
                'GRID_POINT_ARRAY tmp_arr[4];\n'
                'PARAM h;\n'
                '\n'
                'tmp_arr[0] =  0.112999479323160 * F[0];\n'
                'tmp_arr[0] +=  -0.0403092207235200 * F[1];\n'
                'tmp_arr[0] +=  0.0258023774203400 * F[2];\n'
                'tmp_arr[0] +=  -0.00990467650730000 * F[3];\n'
                'Y[0] = tmp_arr[0] * h + y_old;\n'
                'tmp_arr[1] =  0.234383995747400 * F[0];\n'
                'tmp_arr[1] +=  0.206892573935360 * F[1];\n'
                'tmp_arr[1] +=  -0.0478571280485400 * F[2];\n'
                'tmp_arr[1] +=  0.0160474228065200 * F[3];\n'
                'Y[1] = tmp_arr[1] * h + y_old;\n'
                'tmp_arr[2] =  0.216681784623250 * F[0];\n'
                'tmp_arr[2] +=  0.406123263867370 * F[1];\n'
                'tmp_arr[2] +=  0.189036518170060 * F[2];\n'
                'tmp_arr[2] +=  -0.0241821048998300 * F[3];\n'
                'Y[2] = tmp_arr[2] * h + y_old;\n'
                'tmp_arr[3] =  0.220462211176770 * F[0];\n'
                'tmp_arr[3] +=  0.388193468843170 * F[1];\n'
                'tmp_arr[3] +=  0.328844319980060 * F[2];\n'
                'tmp_arr[3] +=  0.0625000000000000 * F[3];\n'
                'Y[3] = tmp_arr[3] * h + y_old;\n',
            'ys_RHS_Approx_ji_plain_Heat3D':
                'GRID_ARRAY Yprev[4];\n'
                'GRID_POINT tmp;\n'
                'GRID_POINT_ARRAY b[4];\n'
                '\n'
                'tmp = 0.220462211176770 * RHS(Yprev[0], {{"g2", g * g}}, Heat3D_offsite, 0.0885879595126800);\n'
                'tmp += 0.388193468843170 * RHS(Yprev[1], {{"g2", g * g}}, Heat3D_offsite, 0.409466864440740);\n'
                'tmp += 0.328844319980060 * RHS(Yprev[2], {{"g2", g * g}}, Heat3D_offsite, 0.787659461760850);\n'
                'tmp += 0.0625000000000000 * RHS(Yprev[3], {{"g2", g * g}}, Heat3D_offsite, 1.00000000000000);\n'
                'y_new = tmp;\n',
            'ys_RHS_Approx_Update_jl_plain_Heat3D':
                'GRID_ARRAY Yprev[4];\n'
                'GRID_POINT tmp;\n'
                'PARAM dt;\n'
                '\n'
                'tmp = 0.220462211176770 * RHS(Yprev[0], {{"g2", g * g}}, Heat3D_offsite, 0.0885879595126800);\n'
                'tmp += 0.388193468843170 * RHS(Yprev[1], {{"g2", g * g}}, Heat3D_offsite, 0.409466864440740);\n'
                'tmp += 0.328844319980060 * RHS(Yprev[2], {{"g2", g * g}}, Heat3D_offsite, 0.787659461760850);\n'
                'tmp += 0.0625000000000000 * RHS(Yprev[3], {{"g2", g * g}}, Heat3D_offsite, 1.00000000000000);\n'
                'y_new = y_old + dt * tmp;\n',
            'ys_RHS_jl_plain_Heat3D':
                'PARAM dt;\n'
                'GRID_ARRAY Yprev[4];\n'
                'GRID_POINT_ARRAY c[4];\n'
                '\n'
                'Ycur[0] = RHS(Yprev[0], {{"g2", g * g}}, Heat3D_offsite, 0.0885879595126800);\n'
                'Ycur[1] = RHS(Yprev[1], {{"g2", g * g}}, Heat3D_offsite, 0.409466864440740);\n'
                'Ycur[2] = RHS(Yprev[2], {{"g2", g * g}}, Heat3D_offsite, 0.787659461760850);\n'
                'Ycur[3] = RHS(Yprev[3], {{"g2", g * g}}, Heat3D_offsite, 1.00000000000000);\n',
            'ys_RHS_predictor_jl_plain_Heat3D':
                'PARAM dt;\n'
                'GRID_ARRAY Yprev[4];\n'
                'GRID_POINT_ARRAY c[4];\n'
                '\n'
                'Ycur[0] = RHS(y_old, {{"g2", g * g}}, Heat3D_offsite, 0.0885879595126800);\n'
                'Ycur[1] = RHS(y_old, {{"g2", g * g}}, Heat3D_offsite, 0.409466864440740);\n'
                'Ycur[2] = RHS(y_old, {{"g2", g * g}}, Heat3D_offsite, 0.787659461760850);\n'
                'Ycur[3] = RHS(y_old, {{"g2", g * g}}, Heat3D_offsite, 1.00000000000000);\n',
            'ys_RHS_LC_predictor_jil_plain_Heat3D':
                'GRID_ARRAY Ycur[4];\n'
                'GRID_POINT_ARRAY tmp_arr[4];\n'
                'GRID_POINT tmp;\n'
                'PARAM dt;\n'
                '\n'
                'tmp = RHS(y_old, {{"g2", g * g}}, Heat3D_offsite, 0.0885879595126800);\n'
                'tmp_arr[0] = 0.112999479323160 * tmp;\n'
                'tmp_arr[1] = 0.234383995747400 * tmp;\n'
                'tmp_arr[2] = 0.216681784623250 * tmp;\n'
                'tmp_arr[3] = 0.220462211176770 * tmp;\n'
                'tmp = RHS(y_old, {{"g2", g * g}}, Heat3D_offsite, 0.409466864440740);\n'
                'tmp_arr[0] += -0.0403092207235200 * tmp;\n'
                'tmp_arr[1] += 0.206892573935360 * tmp;\n'
                'tmp_arr[2] += 0.406123263867370 * tmp;\n'
                'tmp_arr[3] += 0.388193468843170 * tmp;\n'
                'tmp = RHS(y_old, {{"g2", g * g}}, Heat3D_offsite, 0.787659461760850);\n'
                'tmp_arr[0] += 0.0258023774203400 * tmp;\n'
                'tmp_arr[1] += -0.0478571280485400 * tmp;\n'
                'tmp_arr[2] += 0.189036518170060 * tmp;\n'
                'tmp_arr[3] += 0.328844319980060 * tmp;\n'
                'tmp = RHS(y_old, {{"g2", g * g}}, Heat3D_offsite, 1.00000000000000);\n'
                'tmp_arr[0] += -0.00990467650730000 * tmp;\n'
                'tmp_arr[1] += 0.0160474228065200 * tmp;\n'
                'tmp_arr[2] += -0.0241821048998300 * tmp;\n'
                'tmp_arr[3] += 0.0625000000000000 * tmp;\n'
                'Ycur[0] = tmp_arr[0] * dt + y_old;\n'
                'Ycur[1] = tmp_arr[1] * dt + y_old;\n'
                'Ycur[2] = tmp_arr[2] * dt + y_old;\n'
                'Ycur[3] = tmp_arr[3] * dt + y_old;\n',
            'ys_RHS_LC_jil_plain_Heat3D':
                'GRID_ARRAY Yprev[4];\n'
                'GRID_ARRAY Ycur[4];\n'
                'GRID_POINT_ARRAY tmp_arr[4];\n'
                'GRID_POINT tmp;\n'
                'PARAM dt;\n'
                '\n'
                'tmp = RHS(Yprev[0], {{"g2", g * g}}, Heat3D_offsite, 0.0885879595126800);\n'
                'tmp_arr[0] = 0.112999479323160 * tmp;\n'
                'tmp_arr[1] = 0.234383995747400 * tmp;\n'
                'tmp_arr[2] = 0.216681784623250 * tmp;\n'
                'tmp_arr[3] = 0.220462211176770 * tmp;\n'
                'tmp = RHS(Yprev[1], {{"g2", g * g}}, Heat3D_offsite, 0.409466864440740);\n'
                'tmp_arr[0] += -0.0403092207235200 * tmp;\n'
                'tmp_arr[1] += 0.206892573935360 * tmp;\n'
                'tmp_arr[2] += 0.406123263867370 * tmp;\n'
                'tmp_arr[3] += 0.388193468843170 * tmp;\n'
                'tmp = RHS(Yprev[2], {{"g2", g * g}}, Heat3D_offsite, 0.787659461760850);\n'
                'tmp_arr[0] += 0.0258023774203400 * tmp;\n'
                'tmp_arr[1] += -0.0478571280485400 * tmp;\n'
                'tmp_arr[2] += 0.189036518170060 * tmp;\n'
                'tmp_arr[3] += 0.328844319980060 * tmp;\n'
                'tmp = RHS(Yprev[3], {{"g2", g * g}}, Heat3D_offsite, 1.00000000000000);\n'
                'tmp_arr[0] += -0.00990467650730000 * tmp;\n'
                'tmp_arr[1] += 0.0160474228065200 * tmp;\n'
                'tmp_arr[2] += -0.0241821048998300 * tmp;\n'
                'tmp_arr[3] += 0.0625000000000000 * tmp;\n'
                'Ycur[0] = tmp_arr[0] * dt + y_old;\n'
                'Ycur[1] = tmp_arr[1] * dt + y_old;\n'
                'Ycur[2] = tmp_arr[2] * dt + y_old;\n'
                'Ycur[3] = tmp_arr[3] * dt + y_old;\n',
            'ys_Update_j_plain_Heat3D':
                'PARAM dt;\n'
                'GRID dy;\n'
                '\n'
                'y_new = y_old + dt * dy;\n',
        }
        assert kernel in compared_codes
        if compared_codes[kernel] == code:
            return True
        else:
            print(kernel)
            print(code)
            for idx, char in enumerate(compared_codes[kernel]):
                try:
                    if char != code[idx]:
                        print('Expected = "{}"'.format(char))
                        print('Got = "{}"'.format(code[idx]))
                        print('Position = "{}"'.format(idx))
                        break
                except IndexError:
                    print('Expected = "{}"'.format(char))
                    print('Position = "{}"'.format(idx))
                    break
            return False
